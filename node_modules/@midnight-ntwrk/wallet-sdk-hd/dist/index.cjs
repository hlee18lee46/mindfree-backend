'use strict';

var bip32 = require('@scure/bip32');
var bip39 = require('@scure/bip39');
var english = require('@scure/bip39/wordlists/english');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var bip39__namespace = /*#__PURE__*/_interopNamespaceDefault(bip39);

const Roles = {
    NightExternal: 0,
    NightInternal: 1,
    Dust: 2,
    Zswap: 3,
    Metadata: 4,
};
const PURPOSE = 44;
const COIN_TYPE = 2400;
class HDWallet {
    rootKey;
    constructor(key) {
        this.rootKey = key;
    }
    static fromSeed(seed) {
        try {
            const rootKey = bip32.HDKey.fromMasterSeed(seed);
            return { type: 'seedOk', hdWallet: new HDWallet(rootKey) };
        }
        catch (e) {
            return { type: 'seedError', error: e };
        }
    }
    // Begin by selecting an account.
    selectAccount(account) {
        return new AccountKey(this.rootKey, account);
    }
}
class AccountKey {
    rootKey;
    account;
    constructor(rootKey, account) {
        this.rootKey = rootKey;
        this.account = account;
    }
    // After account, select a role.
    selectRole(role) {
        return new RoleKey(this.rootKey, this.account, role);
    }
}
class RoleKey {
    rootKey;
    account;
    role;
    constructor(rootKey, account, role) {
        this.rootKey = rootKey;
        this.account = account;
        this.role = role;
    }
    // Finally, derive the key at the given index.
    deriveKeyAt(index) {
        const path = `m/${PURPOSE}'/${COIN_TYPE}'/${this.account}'/${this.role}/${index}`;
        const derivedKey = this.rootKey.derive(path);
        return derivedKey.privateKey ? { type: 'keyDerived', key: derivedKey.privateKey } : { type: 'keyOutOfBounds' };
    }
}

const mnemonicToWords = (mnemonic) => mnemonic.split(' ');
/** A wrapper around the bip39 package function, with default strength applied to produce 24 words */
const generateMnemonicWords = (strength = 256) => mnemonicToWords(bip39__namespace.generateMnemonic(english.wordlist, strength));
const joinMnemonicWords = (mnenomic) => mnenomic.join(' ');
const generateRandomSeed = (strength = 256) => {
    return crypto.getRandomValues(new Uint8Array(Math.ceil(strength / 8)));
};
/** A wrapper around the bip39 package function */
const validateMnemonic = (mnemonic) => bip39__namespace.validateMnemonic(mnemonic, english.wordlist);

exports.AccountKey = AccountKey;
exports.HDWallet = HDWallet;
exports.RoleKey = RoleKey;
exports.Roles = Roles;
exports.generateMnemonicWords = generateMnemonicWords;
exports.generateRandomSeed = generateRandomSeed;
exports.joinMnemonicWords = joinMnemonicWords;
exports.mnemonicToWords = mnemonicToWords;
exports.validateMnemonic = validateMnemonic;
//# sourceMappingURL=index.cjs.map
